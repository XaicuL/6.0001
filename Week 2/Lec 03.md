# **Algorithms & Strings**

**1. 문자열 (String Manipulation)**

• **인덱싱 (Indexing):**

   ◦ 0부터 시작 (`s`).

   ◦ 음수 인덱스는 뒤에서부터 셈 (`s[-1]`은 마지막 문자) 

• **슬라이싱 (Slicing):** `s[start:stop:step]`

   ◦ `start`부터 `stop-1`까지 `step` 간격으로 가져옴.

   ◦ `s[::-1]`: 문자열 뒤집기 (자주 쓰이는 테크닉!) 
   
• **불변성 (Immutability):**

   ◦ 한번 생성된 문자열은 수정할 수 없음.

   ◦ `s = 'y'` (❌ 에러 발생). 수정하려면 새로운 문자열을 만들어야 함 (`s = 'y' + s[1:]`) 

**2. 알고리즘 전략 1: Guess and Check**

• **개념:** 가능한 모든 경우의 수(Exhaustive Enumeration)를 하나씩 대입해 보며 정답을 찾는 방법 

• **장점:** 이해하기 쉽고 구현이 간단함.

• **단점:** 경우의 수가 많으면 너무 느림.

**3. 알고리즘 전략 2: Approximate Solutions**

• **개념:** 정확한 답(Exact match)을 찾기 어려울 때, "충분히 좋은(good enough)" 답을 찾는 방법.

• **핵심 요소:**

 `epsilon` (ϵ): 허용 오차 범위 (예: 0.01). 답이 이 범위 안에 들어오면 성공으로 간주한다

 ◦ `step` (증가량): 조금씩 값을 증가시키며 확인.

• **트레이드오프:**

    ◦ `step`이 너무 작으면? → 정확도는 높지만 속도가 느림.

    ◦ `step`이 너무 크면? → 답을 건너뛸(Skip) 위험이 있음 [Source 155].

**4. 알고리즘 전략 3: Bisection Search**

• **개념:** 탐색 범위를 절반씩 줄여가며 답을 찾는 방법 (Up/Down 게임과 동일) 

• **조건:** 데이터가 **정렬(Sorted)**되어 있거나, 답의 범위가 연속적이어야 함.

• **성능:** O(logN)으로 매우 빠름. (예: 100만 개의 데이터도 20번 정도면 찾음) 